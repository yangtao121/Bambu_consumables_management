下面我把整套系统重新按“整体架构师交付给实现团队”的方式写一遍，补全你指出的所有缺失点，并把每个点该怎么做、怎么做更合适、如何保证可扩展性讲清楚（不写具体代码）。

---

# 0. 当前进度（先看这里）

如果你想快速知道“现在代码已经能做什么/跑通到哪里/还缺什么”，请优先看：
- `docs/当前进度与已实现功能.md`

# 1. 产品目标与边界

你要做的是一个「**局域网连接拓竹打印机** → **自动同步打印任务与AMS托盘** → **把消耗记到对应耗材卷** → **成本管理与历史追溯**」的系统。

核心能力拆成 6 个闭环：

1. 连接打印机（LAN）
2. 读取“打印状态 + AMS/托盘信息 + 当前使用托盘”
3. 用户管理耗材卷（录入、绑定、盘点、用完/报废）
4. 打印时自动归因耗材（用哪卷）并估算/记录消耗
5. 历史消耗与成本报表（可追溯、可纠错）
6. 前端交互（清晰、可控、低维护）

---

# 2. 总体架构（单体 + 事件驱动内核，最适合你这种系统）

## 2.1 四层分离（必须做到）

* **Domain（领域层）**：耗材卷、打印任务、扣料记录、成本规则（纯业务）
* **Application（用例层）**：把“事件 → 业务动作”串起来（开始打印、结束扣料、托盘切换…）
* **Infrastructure（基础设施）**：MQTT/DB/3MF解析/缓存
* **Interface（接口层）**：FastAPI REST + WebSocket/SSE；Next.js UI

> 采集协议变、固件字段变、UI改版，都不应该把 Domain 搞乱。

## 2.2 事件驱动的原因

打印机来的不是“数据表更新”，而是“状态流”。所以你要做的是：

**MQTT 原始消息 → 标准化事件 NormalizedEvent → 用例处理 → 产出业务记录 → UI实时更新**

这样可扩展性会非常强：以后你加别的品牌打印机，只要换“驱动+解析”，业务不动。

---

# 3. 局域网读取拓竹耗材/打印信息（你缺的这一块）

## 3.1 连接方式（设计思路）

拓竹局域网最实用的方式是：

* **使用打印机 LAN 模式 + MQTT 状态上报流**
* 采集进程（collector）对每台打印机保持一个连接，订阅 report topic
* 从 report 里抽取你关心的“打印状态”“当前tray”“AMS托盘信息（颜色/材质/剩余等）”

> 你不需要在业务层理解 MQTT 细节；业务层只理解 “PrintStarted / TraySwitched / PrintEnded …”。

## 3.2 实施骨架（Collector 里要做什么）

Collector 模块只做 4 件事：

1. **设备配置**：每台打印机保存 ip、serial、LAN access code（以及型号/别名）
2. **连接管理**：自动重连（指数退避）、心跳/last_seen、掉线状态
3. **解析器**：把 MQTT payload 解析成标准事件（NormalizedEvent）
4. **落 raw_events**：保存原始消息（强烈建议，后期排错必需）

### 标准事件要包含什么

NormalizedEvent 至少要有：

* event_id（用于幂等，避免重复扣料）
* printer_id
* type：PrintStarted / PrintProgress / PrintEnded / PrintFailed / TraySwitched / AmsUpdated …
* occurred_at（事件时间）
* data（规范化字段，比如 job_key、tray_now、progress、estimated_remaining_time、tray_list…）
* raw_ref（指向 raw_events 记录）

## 3.3 你从状态流里要抽取哪些字段（对功能最关键）

你至少要能得到：

* **打印生命周期**：开始/进行中/结束/失败（用于触发扣料）
* **当前使用托盘 tray_now**：本次打印到底用哪个槽
* **AMS托盘列表**：每个 tray 的属性（颜色、材质、可能的剩余量等）

注意：不同固件字段可能变，你要在 parser 层做“兼容映射”，保证上层看到的字段稳定。

## 3.4 读取“消耗量”的策略（不要只押宝 AMS 剩余）

现实里 AMS “剩余量”字段不一定稳定、不同机型表现不同。所以系统设计上必须 **多策略**：

* **策略A：AMS剩余差值**（自动、但可能不准/缺失）
* **策略B：切片文件元数据（3MF/GCode）用量**（稳定兜底，尤其多色打印很强）
* **策略C：人工录入/纠错**（最终兜底）

你用“估算策略插件”把这三种都纳入，按优先级尝试，并记录 confidence（置信度）。

---

# 4. 用户如何添加耗材（字段设计 + 录入体验）

## 4.1 “耗材卷 Spool”建议字段（务实且可扩展）

### 必填（最少可用）

* 名称/别名（用户可识别，比如“PLA 白 1kg”）
* 材质 material（PLA/PETG/ABS/TPU… 可枚举 + 自定义）
* 颜色 color（可颜色选择器 + 文本）
* **初始重量 initial_grams**（建议用克）
* **价格 price**（总价）或 price_per_kg（二选一，建议都支持）
* 供应商/品牌 brand（可选但很有用）
* 直径 diameter（1.75/2.85，默认 1.75）

### 强烈建议（对成本、准确度很关键）

* 购买日期 purchase_date
* 批次 batch_id（便于同款不同批次）
* 空盘重量 tare_grams（很多人会有，能提升剩余估算准确性）
* 备注 note（比如“含玻纤”“容易拉丝”）

### 系统字段（自动维护）

* 状态 status：active / empty / retired / unknown
* 估计剩余 remaining_grams_est（由扣料记录聚合得出）
* 创建/更新时间
* 标签 tag（二维码/条码，绑定 tray 更快）

> “输入长度（米）/密度”这类可以做高级选项；别一开始强制，否则用户会嫌烦。

## 4.2 添加耗材的交互流程（要快、要少脑力）

建议两条入口：

1. **快速添加（90%用户用这个）**

   * 名称、材质、颜色、初始重量、价格（总价）
   * 创建后立即提示：是否绑定到某台打印机某个 tray

2. **高级添加（给重度用户）**

   * 加 tare_grams、批次、供应商、密度、成本策略、标签二维码等

---

# 5. 用完后如何清除/处理一卷耗材（必须支持审计）

不要直接“删除 Spool”，否则历史报表会断链。正确做法：

## 5.1 Spool 生命周期

* **Active**：正常使用中
* **Empty**：用完（剩余=0 或用户确认用完）
* **Retired**：报废/丢弃/送人/不可追溯
* **Archived**：仅用于历史查询（不参与绑定）

## 5.2 “用完/清除”的操作设计

在 UI 上提供三种按钮（都要写入审计记录）：

1. **标记用完（Empty）**

   * remaining_grams_est 归零
   * 自动解除所有 tray 绑定（或提示用户解除）
   * 不影响历史 consumption_records

2. **盘点调整（Inventory Adjust）**

   * 用户输入“实际剩余克数”
   * 系统生成一条 adjustment record（不是改旧记录）
   * 让审计链完整：你能解释“为什么剩余突然变多/变少”

3. **报废/归档（Retire/Archive）**

   * 状态变更，禁止再绑定
   * 保留所有历史

---

# 6. 打印机工作时如何同步“用了哪卷 + 消耗多少”（你最核心的自动化）

这块你要设计得足够稳，不然用户会失去信任。

## 6.1 “归因：本次打印用哪卷”

最可靠做法是：**任务开始时锁定归因上下文**。

当收到 PrintStarted：

* 创建/更新 PrintJob
* 读取 tray_now（或等第一条包含 tray_now 的事件）
* 根据 tray_mappings 找到对应 spool_id
* 在 PrintJob 上记录 `spool_binding_snapshot`（快照：当时 tray->spool 映射）

为什么要快照：用户可能中途改绑定；你必须能追溯“当时实际绑定是谁”。

## 6.2 扣料触发时机

* **建议在 PrintEnded / PrintFailed 时结算扣料**
* 过程中可以显示“预计消耗”，但不要立刻扣减（否则失败任务会污染库存）

## 6.3 消耗量估算（多策略 + 可解释）

结算时调用 ConsumptionService：

输入：job、快照映射、（可选）slice元数据、ams剩余
输出：一个或多个 ConsumptionRecord（可能多色、多托盘）

### 估算策略优先级建议

1. **切片元数据按托盘用量**（多色最强，能分摊到每个 tray）
2. **AMS剩余差值**（如果可用且可信）
3. **总用量 + 托盘切换分摊**（按时间比例等，标低置信度）
4. **人工补录**（置信度最高，但需要人）

### 关键：每条 ConsumptionRecord 都要写 source + confidence

前端展示时用户一眼知道：这条是“自动精确”还是“估算/需要确认”。

## 6.4 托盘切换（多色/中途换料）怎么做

你至少要支持两级实现：

* **基础版（先做这个就能用）**

  * 若 slice 元数据可得：直接按 tray 用量生成多条 record
  * 若 slice 不可得：只记录“本次主托盘”（低置信度）

* **增强版（后续迭代）**

  * 监听 TraySwitched 事件，形成 segments（每段用哪个 tray）
  * 若只有总用量：按 segment 时间占比分摊到每个 tray（并标注低置信度）

---

# 7. 历史消耗耗材查看（用户真正会天天用的功能）

你至少要做 3 个视图，且都能过滤/导出：

## 7.1 “耗材卷账本”（Spool Ledger）

进入某个 Spool：

* 当前剩余估计
* 历史扣料列表（按时间倒序）
* 每条记录可点开对应 job
* 支持“盘点调整/纠错”

这是最能建立信任的页面。

## 7.2 “打印任务历史”（Job History）

列表字段建议：

* 时间、打印机、文件名/任务名、状态、用到的 spool(s)、总消耗克数、成本
* 点进详情：事件时间线（开始、换料、结束、结算、纠错）

## 7.3 “成本与用量报表”（Reports）

最实用的三类：

* 按月总消耗（克、金额）
* 按材质/颜色/品牌分组
* 按打印机分组

---

# 8. 前端交互界面逻辑与风格（Next.js 方案）

## 8.1 页面信息架构（IA）

建议左侧导航：

* Dashboard（总览：在线打印机、正在打印、今日消耗）
* Printers（打印机管理：连接状态、当前任务、AMS托盘）
* Spools（耗材卷管理：库存、添加、盘点、用完）
* Jobs（打印历史：可搜索、筛选、导出）
* Reports（报表）
* Settings（成本策略、单位、标签/二维码、权限）

## 8.2 每个页面的交互要点

### Dashboard

* 卡片：在线/离线打印机数、正在打印任务数、过去7天消耗
* 实时更新：打印机状态、进度条
* 风格：信息密度适中，别搞表格塞满

### Printers 列表 → 详情页

详情页必须有：

* 连接状态（绿/灰）、last_seen、IP
* 当前任务（名称、进度、预计剩余时间）
* AMS 托盘表格：tray_id、颜色、材质、绑定的 Spool、剩余估计/可信度
* “一键绑定”：从托盘行直接选择某个 spool

### Spools 列表 → 新增/详情

* 列表：剩余估计、材质/颜色、单价、状态、是否被绑定
* 新增：快速模式 / 高级模式
* 详情：Spool ledger（扣料记录）、盘点调整、标记用完、解绑提示

### Jobs

* 强搜索：按文件名、打印机、日期、spool
* 详情：事件时间线 + 消耗结算结果 + 纠错入口

### Reports

* 先做简单聚合 + 导出 CSV
* 图表要克制（趋势折线/柱状即可）

## 8.3 UI 风格建议（省维护、看起来专业）

* 组件库：shadcn/ui（搭配 Tailwind）
* 统一色彩语义：状态 badge（在线、打印中、异常、需确认）
* DataTable 统一：分页、排序、筛选抽屉
* 表单统一：react-hook-form + zod；错误提示一致
* 每个“破坏性操作”（标记用完、报废、盘点覆盖）必须二次确认 + 写审计日志

## 8.4 实时更新（WS/SSE）在 UI 里怎么用

* Printers 列表和详情页：订阅 printer/<id> 频道，实时刷新进度与 tray_now
* Dashboard：订阅 summary 或订阅所有 printer 的轻量事件
* Jobs 详情：订阅 job/<id>，展示事件流

---

# 9. 后端 API 与数据模型（确保前后端长期稳定）

## 9.1 数据表（必须支持审计与纠错）

你要至少有：

* printers
* spools
* tray_mappings（支持历史：bound_at/unbound_at）
* print_jobs
* consumption_records（事实记录）
* inventory_adjustments（盘点调整记录）
* raw_events（排错与回放）

核心原则：
**consumption_records 是“事实账本”，spools.remaining_est 是“聚合视图”**。
这样才能重算、纠错、回放。

## 9.2 API 设计（对前端最友好）

* CRUD：printers/spools/mappings
* jobs：列表/详情/搜索
* consumptions：列表/按spool/job查询
* adjustments：盘点/纠错
* reports：聚合 + 导出
* realtime：WS/SSE

错误返回统一结构，前端好处理：code/message/trace_id/detail。

---

# 10. 关键边界情况（你做得好就赢一大半）

1. **用户中途改绑定**：必须用 job 快照归因
2. **打印失败/取消**：要记录，但扣料策略可选（默认不扣或标低置信度）
3. **AMS剩余不可用**：必须 fallback 到 slice 或手动
4. **多色打印**：最好从 slice 元数据直接拿每托盘用量
5. **重复事件/断线重连**：event_id 幂等，避免重复扣料
6. **用户手动盘点**：永远写 adjustment，不改历史扣料记录

---

# 11. 给 Cursor 的实现路线（按迭代交付）

MVP（最小可信版本）

1. 打印机连接 + 状态读（打印中/空闲 + tray_now + 托盘表）
2. Spool CRUD + tray 绑定
3. PrintJob 历史记录（开始/结束）
4. 结束时生成 consumption_record（先用 slice 或简单估算）
5. Spool 详情账本 + 标记用完 + 盘点调整
6. 前端 Dashboard + Printers + Spools + Jobs

增强版
7) 多色按托盘用量精确扣料
8) Realtime 全面推送
9) 报表与导出
10) 事件回放与纠错工具

---

如果你愿意，我可以把这份 guideline 再进一步“工程化”：给你一个**逐文件的骨架清单**（每个目录下要有哪些文件、每个文件定义哪些接口/类、输入输出 DTO 结构长什么样、哪些地方必须加唯一索引做幂等），这样 Cursor 基本可以按清单一次性搭得很规整。
