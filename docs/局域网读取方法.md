要在**局域网内读取拓竹（Bambu Lab）打印机的耗材/打印信息**，目前最通用、最稳定的入口是：**直连打印机内置的 MQTT 服务（状态上报）**。很多第三方集成（比如 Home Assistant 的 ha-bambulab）也是这么做的。([Gist][1])

---

## 1) 局域网连接的关键：MQTT（状态流）

你需要的最小信息：

* 打印机 IP（同一局域网）
* 打印机序列号 serial（用于 topic）
* LAN Access Code（密码）
* MQTT 端口通常是 **8883（TLS）**
* 用户名通常是 **`bblp`**
* 订阅 topic：`device/<serial>/report`（状态上报）
  -（可选）发布 topic：`device/<serial>/request`（下发控制命令）

下面这个公开脚本就是标准做法：用 `paho-mqtt`，TLS 连接 8883，`username=bblp`、`password=LAN code`，订阅 `device/<serial>/report`。([Gist][1])

---

## 2) 状态消息里有哪些“跟耗材相关”的字段？

MQTT 上报 payload 是 JSON，通常会有 `print` 字段（打印进度/状态），以及 AMS 相关结构。([Home Assistant Community][2])

### 打印生命周期（用于判断“什么时候开始/结束一次打印”）

社区里常见字段包括：

* `gcode_state`（例如 PREPARE/RUNNING/IDLE/FAILED）
* `mc_print_stage`
* `mc_remaining_time`（有人实测更像“分钟”，用于估算结束时间要 *60）([Home Assistant Community][2])
* `gcode_start_time`（Unix epoch）([Home Assistant Community][2])
* `gcode_file`（但可能不可靠；有人建议用 subtask/当前任务名更好）([Home Assistant Community][2])

### AMS / 当前用的是哪一盘料

关键点是：在打印中会出现 `tray_now`（当前正在用的托盘 id），它能和 `ams.tray` 数组里每个 tray 的 `id` 对上，从而知道“本次打印正在用哪一格”。([Home Assistant Community][2])

ha-bambulab 文档也明确 AMS “Tray 实体”会暴露很多属性（颜色、类型、**Remaining Filament** 等）。([docs.page][3])

---

## 3) “消耗量”怎么拿到？两条路线（推荐你两条都做）

### 路线 A：用 AMS 的“Remaining Filament / remain”做差（最自动）

做法：

1. 侦测到打印开始（`gcode_state` 从 IDLE → PREPARE/RUNNING）
2. 读取 `tray_now`，定位到当前 tray
3. 记录该 tray 的 `remain`（或对应“剩余量”字段）
4. 打印结束（RUNNING → IDLE/FAILED/FINISH）再读一次 remain
5. 消耗 = start_remain - end_remain

但要注意现实问题：

* 有用户反馈 `remain` 可能会变成 **-1** 不更新（固件/模型/模式差异）。([GitHub][4])
* **AMS Lite** 上也有人遇到“剩余量总是 100%”这类不可信情况。([GitHub][5])

所以：路线 A 很香，但你要准备 fallback。

### 路线 B：从作业文件/切片元数据拿“该次打印预计用料”（更稳，偏工程）

WolfwithSword 的 Node-RED 流里就提到：会通过 **FTPS 拉取 3MF / 获取重量**，再做记录/同步。([Gist][6])
这条路线的思想是：**打印机状态告诉你“用了哪卷（tray_now）+ 何时开始/结束”，消耗量则从 3mf/gcode 元信息拿“本次预计用多少克/多少米”。**

这样即使 AMS 不报 remain，你也能把“这次打印消耗”记到正确的卷上（至少是切片估算值）。

---

## 4) 最小 Python 监听示例（你可以直接改成后台服务）

下面是你项目里“采集层”的最小骨架（同步写法，够你验证链路）——逻辑就是：连 MQTT、订阅 report、解析 `print`、识别开始/结束事件。思路和公开脚本一致。([Gist][1])

```python
import json
import ssl
import time
import paho.mqtt.client as mqtt

PRINTER_IP = "192.168.x.x"
PRINTER_SERIAL = "01S00Axxxxxxxxxxxx"   # 打印机序列号
LAN_CODE = "xxxxxxxx"                   # 打印机 LAN Access Code

TOPIC_REPORT = f"device/{PRINTER_SERIAL}/report"

status = {}
last_state = None

def on_connect(client, userdata, flags, reason_code, properties=None):
    print("connected:", reason_code)
    client.subscribe(TOPIC_REPORT)

def on_message(client, userdata, msg):
    global last_state, status
    data = json.loads(msg.payload.decode("utf-8"))

    if "print" not in data:
        return

    p = data["print"]
    gcode_state = p.get("gcode_state")
    tray_now = None
    if isinstance(p.get("ams"), dict):
        tray_now = p["ams"].get("tray_now")  # 社区实测字段:contentReference[oaicite:12]{index=12}

    # 例：识别一次打印开始/结束（你可按自己机型调条件）
    if last_state != gcode_state:
        print("state:", last_state, "->", gcode_state, "tray_now:", tray_now)
        last_state = gcode_state

    # TODO: 在这里把关键字段落库（print_id/开始时间/托盘id/文件名/剩余时间等）

client = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2, protocol=mqtt.MQTTv311)
client.username_pw_set("bblp", LAN_CODE)
client.tls_set(tls_version=ssl.PROTOCOL_TLS, cert_reqs=ssl.CERT_NONE)  # 很多脚本直接不校验证书:contentReference[oaicite:13]{index=13}
client.on_connect = on_connect
client.on_message = on_message

client.connect(PRINTER_IP, 8883)
client.loop_forever()
```

---

## 5) 你要做成“耗材管理系统”的推荐结构（Python Web）

你描述的需求，其实可以拆成三层：

1. **采集层（MQTT watcher）**

* 每台打印机一个连接
* 把 `print` 状态流解析成：print_start、print_end、tray_switch 等事件
  -（可选）抓 3mf/gcode 元数据补齐“本次预计用量”([Gist][6])

2. **业务层（耗材/成本模型）**

* Spool（卷）：材质/颜色/品牌/入库克重/剩余克重/单价（元/kg 或 元/g）
* TrayMapping：AMS 第几格 ↔ 当前绑定哪一卷（可自动：读 tray 的 type/color/serial；也可手动扫码绑定）
* ConsumptionRecord：一次打印消耗（克数/成本/时间/文件名/打印机）

3. **Web 层（FastAPI + 前端）**

* “耗材录入”（入库、单价、初始克重）
* “实时同步”（看到当前 tray_now 在用哪卷、剩余估计）
* “成本报表”（按打印任务/按月份/按耗材）

---

## 6) 两个你一定会踩的坑（提前规避）

* **固件/模式对“写操作”限制越来越多**：ha-bambulab 明确提到新固件下，如果还连着云，很多“写控制”会被限制；但“读状态”一般还可用。你这个项目主要是“读+记账”，影响不大。([docs.page][7])
* **“剩余耗材”并不总是可靠**：`remain=-1` 或 AMS Lite 不更新这种情况是真实存在的，所以务必准备“用切片估算量”作为 fallback。([GitHub][4])

---

如果你愿意，我可以按你当前设备（比如 X1C/P1S/A1 + AMS/AMS Lite、是否 LAN-only）给你一份**可直接跑的 FastAPI 后端骨架**：

* 后台 asyncio MQTT 监听
* SQLite/Postgres 表结构（spool、tray_mapping、print_job、consumption）
* 打印开始/结束自动记账（remain 优先，3mf/gcode 估算兜底）

[1]: https://gist.github.com/lin-ycv/14a8b091ed5d16ed9d519fa3ebc0caf7 "Python scripts to monitor Bambu lab printer print status over local MQTT (LAN), sends print info to a backend server when a new print starts, and allows the backender server to terminate a print if needed · GitHub"
[2]: https://community.home-assistant.io/t/bambu-lab-x1-x1c-mqtt/489510 "Bambu Lab X1 X1C MQTT - Configuration - Home Assistant Community"
[3]: https://docs.page/greghesp/ha-bambulab/entities "Entities"
[4]: https://github.com/greghesp/ha-bambulab/issues/821?utm_source=chatgpt.com "[Bug] remaining filament not updating anymore · Issue #821"
[5]: https://github.com/greghesp/ha-bambulab/issues/580?utm_source=chatgpt.com "[Bug] A1 + AMS Lite Remaining filament always at 100%"
[6]: https://gist.github.com/WolfwithSword/e3e4dc4f00629cc047b7cefd70d7b350?utm_source=chatgpt.com "Node-RED Flow - BambuLab X1 MQTT Relay for Home ..."
[7]: https://docs.page/greghesp/ha-bambulab "Integration Overview"
